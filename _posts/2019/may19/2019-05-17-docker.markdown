---
layout: post
title:  "Docker - an overview!"
date:   2019-05-17 16:58:08
categories: infra
permalink: /:categories/docker
---

<p><em>Last update: 2024-05-01</em></p>

<p style="text-align: justify;">Today I will talk about <a href="https://www.docker.com/">Docker</a>. It is a nice whale that has been appearing in the development environment.</p>

<p style="text-align: justify;">Yeah. Reading something about that I was very enthusiastic with that. Who usually studies new IT topics to perform some tests knows how annoying sometimes have to go installing and configuring various tools, polluting your computer with various technologies to perform some tests and then have to discard. With docker this can be solved. With docker you can centralize these settings and, when you finish your tests, you can throw away or even save a portion of the environment that you can use at other times.</p>

<p style="text-align: justify;">Of course, Docker is muuuuuch more than that. Docker helps you through the entire development process, from the development itself to the production environment.</p>

<p style="text-align: justify;">Good, but my goal here is to just give you a general idea about what docker is and what it can bring of benefits. And from there each one will be able to deepen according to two needs.</p>

<p style="text-align: justify;">Let’s go!!!.</p>

<h3>What is it – An Overview</h3>

<p style="text-align: justify;"><a href="https://docs.docker.com/engine/docker-overview/">Docker</a> is an open source project that aims to leave applications in containers. Docker can be used to develop, deploy, and run applications. It allows you to separate the application from the infrastructure.</p>

<p style="text-align: justify;">Anyone who works developing application knows how annoying it is often to worry about the environment itself instead of focusing on the main focus that is developing features.</p>

<p style="text-align: justify;">The docker is based on client-server architecture where the client initiates a request to the server (deamon), the server can be remote or not. This communication is performed via <a href="https://pt.wikipedia.org/wiki/REST">REST API</a>, CLI (terminal) and the Kitematic (GUI).

<p style="text-align: justify;">Some confusion is common when start tje studies on Docker. One of that is the fact that Docker is not virtual machine (VM).</p>

<p style="text-align: justify;">A good comparison was made in the <em>eBook: Docker-for-Virtualization-Admin</em> that compares VM to a house and the Docker is compared to an apartment. In a house, the whole structure is individual and independent, while in an apartment a part of the structure is shared. You can create Docker image only with what will be used in your application. While the VMs start with the complete operating system and depending on the application, the developer may or may not perform some customization. But that does not mean that VM and Docker container cannot coexist. It is possible to have a Docker container inside a VM.</p>

<p style="text-align: justify;">In a simplistic way, we can consider that docker is something to manage an easy, small portion of the infrastructure needed to run an application. It is possible to have more than one such structure in communication, but this detail I leave for who will need to go deep according to their needs.</p>

<h3>Terminology</h3>

<ul>
  <li><a href="https://docs.docker.com/engine/">Docker Engine: </a> is an open source containerization technology for building and containerizing your applications.</li>
  <li><a href="https://docs.docker.com/desktop/">Doker Desktop </a> (Daemon and CLI) is a simple application to build, share and run containerized applications and microservices. However, the terms of use was changed and now is necessary a license to use. As alternative, you can use, for instance, <a href="https://smallsharpsoftwaretools.com/tutorials/use-colima-to-run-docker-containers-on-macos/">Colima</a>.</li>
  <li><a href="https://docs.docker.com/get-started/overview/#images">Image</a>: read-only template with instructions for creating a Docker container.</li>
  <li>Container: A standardized unit of software. A package of code and dependencies to run that code. The same container always have the same application and execution behavior.</li>
  <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#what-is-a-dockerfile">Dockerfiles</a>: scripts that automate the process of constructing images; they define what will exist inside the containers. It is a simple text file with a list of commands that will indicate to the client docker what should be created in the image.</li>
  <li><a href="https://docs.docker.com/get-started/overview/#containers">Containers</a>: runnable instance of an image</li>
  <li><a href="https://hub.docker.com/">Docker Hub</a>: Register of images. You can see how to use <a href="https://docs.docker.com/docker-hub/quickstart/">here</a>.</li>
  <li><a href="https://docs.docker.com/storage/volumes/">Volumes</a>: mechanism for persisting data managed by Docker. The contents are outside of the container's scope. Volumes are folders on the host machine mounted into containers. It is mmanaged by docker and can be anonynous or named. Anonymous volumes are removed automatically when the container is removed when you use '--rm' to start the container. If nor, the volume will not be removed but a new anonmous volume is attached to the container when it starts again. </li>
  <li>Bind Mounts: A similar concept of volume, but it is managed by the developer. The developer define the folder ot oath on the host machine. It is better to persistent and editable data.</li>
    <li>Data:
    <ul>
      <li>Application (code + env) [anonymous]: the data in image is read-only</li>
      <li>Temporary App Data (e.g user input) [named]: the data in container is read/write and temporary</li>
      <li>Permanent App Data (e.g user accounts)[Bind Mounts]: the data in volumes is read/write and permanent</li>
    </ul>
  </li>
  <li><a href="https://docs.docker.com/engine/tutorials/networkingcontainers/">Network containers</a>: it make the app available in network. The drivers are bridge (the container is launcheed in this network) and overlay. Networks are natural ways to isolate containers. More example you can see <a href="https://medium.com/@augustineozor/understanding-docker-bridge-network-6e499da50f65">here</a>.</li>
  <li><a href="https://docs.docker.com/network/">docker networking</a></li>
  <li><a href="https://docs.docker.com/get-started/07_multi_container/">Multi container apps</a>: you can have many containers and make the communication by networking.</li>
  <li>Daemon: a portion of the server where there is container management</li>
  <li>CLI: commands and communicates with the docker daemon</li>
  <li>Docker Machine: Creates a host on your computer, in the cloud, or in your data center</li>
  <li><a href="https://docs.docker.com/reference/cli/docker/compose/up/">Docker compose</a>: a tool for defining and executing multi-container applications</li>
  <li>Docker Swarm: native clustering solution for docker;</li>
  <li><a href="https://docs.docker.com/build/guide/layers/">Image Layers</a>: are the instructions in a Dockerfile translated to the image. The order of the instructions is omportant. Each layer can be reuse in a nre build</li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/attach/">Attached and detached containers</a>: the container run in foreground when is attached and you can see the logs. The terminal is blocked. When it is detached it runs in background and the terminal is free. You can use 'logs' command to see the returns.</li>
</ul>


<h3>Commands</h3>

<ul>
  <li><a href="https://docs.docker.com/reference/dockerfile/#cmd">CMD</a>: instruction in Dockerfile that set the command to be executed when running a container from an image</li>
  <li><a href="https://docs.docker.com/reference/dockerfile/#entrypoint">ENTRYPOINT</a>: instruction that allow to configure a container that will run as an executable</li>
  <li><a href="https://spacelift.io/blog/docker-entrypoint-vs-cmd">CMD vs ENTRYPOINT</a>: both are instructions to run when the container start, but ENTRYPOINT sets the process to run, while CMD supplies default arguments to that process</li>
  <li><a href="https://docs.docker.com/develop/develop-images/instructions/#expose">EXPOSE</a>: indicates the ports on which a container listens for connections. Ports exposed from the container.</li>
  <li><a href="https://www.baeldung.com/ops/docker-compose-expose-vs-ports#:~:text=The%20expose%20section%20allows%20us,exposes%20specified%20ports%20from%20containers.">Port Mapping</a>: defined ports internally and published on the host machine.</li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/ls/">docker ls</a></li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/run/">docker run</a></li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/stop/">docker stop</a></li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/exec/">docker exec</a></li>
  <li><a href="https://docs.docker.com/reference/cli/docker/container/kill/#description">docker kill</a></li>
</ul>

<p style="text-align: justify;">If you don't want to install the docker but would like to test it, you can use this <a href="https://labs.play-with-docker.com/">playground</a></p>


<h3>Best Practices</h3>

<ul>
 <li>Have small images</li>
 <li>Use swarm whenever possible</li>
 <li>Use continuous integration for application testing and deployment</li>
 <li>Create ephemeral containers, that is, containers that can be simply replaced.</li>
 <li>Do not install unnecessary things</li>
 <li>Each container must have a goal</li>
</ul>

<h3>Some commands</h3>

{% highlight ruby %}

// x86/amd64 based images on Apple M1/M2 Macs
$ colima start --cpu 2 --memory 4 --arch x86_64

// Apple M1/M2 Macs
$ colima start --cpu 2 --memory 4 --arch aarch64

$ docker build -t NAME:TAG . // build the image with a group and a tag 

// change the name (clone) to push Must be logged (doker login)
$ docker tag OLD_NAME:OLD_TAG DOCKER_HUB_REPO/REMOCE_BUILD_NAME:TAG 

// execute in foreground (block the terminal - attached)
$ docker run MY_IMG_ID 

$ docker run -itd --name=MY_IMG ubuntu

// execute in detache mode
$ docker run -d MY_IMG_ID 

// back to attache mode
$ docker attache MY_IMG_ID 

// local port 3000, docker port 80, detached, 
// remove container when it is stopped, give a specific name
$ docker run -p 3000:80 -d --rm --name MYNAME IMAGE_ID 

// execute in background (detache mode)
$ docker start MY_IMG_NAME 

$ docker logs -f CONTAINER_ID

// see the logs, useful to detache mode then 
// you cannot see the result in the terminal
$ docker logs MY_IMG_NAME 

$ docker inspect MY_IMG

// connect to Docker Hub
$ docker login 
$ docker push MY_HUB_PATH

$ docker volume create MY_VOL
$ docker volume ls
$ docker volume inspect MY_VOLUME

$ docker container stop MY_CONTAINER
$ docker container rm MY_CONTAINER
$ docker volume rm MY_VOLUME
// remove unused anonymous volumes
$ docker volume prune 

// usea name of the volume
$  docker run -d -p 3000:80 --rm --name feedback-app \
-v myfeedback:/app/feedback feedback-node:volumes 

// use the path in your host machine. (Bind Mounts)
// The second volume (anonynous) avoid override the volumes. 
// Useful to change code and don't need re-build the images
$  docker run -d -p 3000:80 --rm --name feedback-app \
-v "MY_LOCAL_PATH:/app" \
-v /app/node_modules feedback-node:volumes 

$ docker network ls
$ docker network inspect bridge
$ docker network disconnect bridge MY_IMG
$ docker network create -d bridge MY_BRIDGE
$ docker network connect MY_BRIDGE MY_IMG

$ docker exec -it MY_SQL mysql -u root -p // iterative

$ docker ps                   // list containers running
$ docker ps -p                // list containers id
$ docker kill $(docker ps -q) // fill all containers
$ docker rm MY_MAGE_NAME
$ docker rm $(docker ps -a -q)
$ docker rmi IMAGE_ID
$ docker rmi $(docker images -q)
$ docker rmi prune            // remove all images
$ docker ps --size            // disk usage

// starts the containers in the background and leaves them running
$ docker compose up --detach 

{% endhighlight %}

<br/>
<h3>Summary</h3>

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8P9NTaE-dLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>

<h3>Course</h3>
<li><a href="https://www.cod3r.com.br/courses/docker">Docker: Ferramenta essencial para Desenvolvedores</a></li>
<li><a href="https://www.udemy.com/course/docker-kubernetes-the-practical-guide/?couponCode=ST2MT43024">Docker & Kubernetes: The Practical Guide [2024 Edition]</a></li>
<li><a href="https://www.udemy.com/course/learn-docker/?couponCode=ST13MT40224">Docker for the Absolute Beginner - Hands On - DevOps
</a></li>

